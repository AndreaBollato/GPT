<!-- 7b9533c3-fbbf-4f3d-8d2c-40ec83836623 49862c8f-e73b-4afb-b9f2-49e37479414b -->
# Piano UI SwiftUI macOS stile chatgpt.com

### Obiettivo e principi

- **Obiettivo**: replicare l’esperienza visiva/UX di chatgpt.com in un’app macOS con SwiftUI: homepage, chat, creazione auto di nuova chat all’invio, sidebar conversazioni.
- **Solo UI**: niente networking o logica API; dati mock e protocolli per staccare la UI dal backend.
- **Tecnologia**: SwiftUI (macOS 13+), `NavigationSplitView`, `Toolbar`, `FocusState`, `ScrollViewReader`.
- **Theming**: Light/Dark auto; palette neutra stile chatgpt.com; tipografia SF Pro e monospaced per code.

### Struttura di navigazione (App shell)

- **Container**: `NavigationSplitView` con **Sidebar** a sinistra e **Detail** (Homepage o Chat) a destra.
- **Toolbar superiore** (nell’area Detail): titolo modello, selettore modello, azioni contestuali (Nuova chat, Stop/Invio, Opzioni...).

Esempio scheletro:

```swift
struct AppRootView: View {
    @State private var selectedConversationId: UUID?
    var body: some View {
        NavigationSplitView {
            SidebarView(selectedConversationId: $selectedConversationId)
        } detail: {
            if let id = selectedConversationId {
                ChatView(conversationId: id)
            } else {
                HomeView()
            }
        }
    }
}
```

### Schermate e componenti

- **Homepage (`HomeView`)**
  - Hero centrale con titolo e sottotitolo.
  - Griglia “suggested prompts” in card (3–4 card per riga, responsive).
  - Composer globale in basso: se si invia da qui e non c’è chat selezionata ⇒ crea nuova conversazione e naviga in Chat.

- **Chat (`ChatView`)**
  - **Header**: nome modello corrente (menu a tendina), stato (idle/typing/streaming), pulsanti Stop/Clear.
  - **Lista messaggi**: `ScrollView` con `LazyVStack`, separatori sottili tra turni, avatar tondi (assistant a sinistra, user a destra), timestamp discreto on-hover.
  - **Rendering contenuto**: Markdown (titoli, liste, link), code block con font monospaced, contenitore con sfondo dedicato e pulsante “Copy”.
  - **Composer**: `TextEditor` multiline, placeholder, invio con ⌘⏎, Shift⏎ = nuova riga, bottone Send (freccia), contatore caratteri/tokens facoltativo.

- **Sidebar (`SidebarView`)**
  - Header con **Nuova chat**, campo ricerca conversazioni.
  - Lista conversazioni in sezioni (Pinned, Recent).
  - Riga conversazione con: titolo (dalla prima user message), snippet ultimo messaggio, badge modello, data relativa. Context menu: Rinomina, Duplica, Elimina, Pin/Unpin.
  - Resizable (drag), collassabile (⌘B).

- **Selettore Modello**
  - Menu a comparsa in header chat; elenco modelli disponibili con descrizione breve; applica lo stile chatgpt.com (etichetta model + caret). Cambiare modello aggiorna il badge conversazione.

- **Messaggi**
  - **Utente (destra)**: bubble allineata a destra, sfondo tenue (grigio/azzurro), radius 12–16, max-width ~ 720pt.
  - **Assistant (sinistra)**: bubble a sinistra, sfondo chiaro con bordo, markdown ricco; code block con copy.
  - Stati: skeleton in arrivo/streaming, indicatori typing (3 dots) nello stesso spot del composer.

### Flussi chiave

- **Nuova chat all’invio**: se `selectedConversationId == nil` e l’utente invia dal composer (homepage o shell), creare `Conversation` con primo `Message(role: .user, ...)`, selezionarla e mostrare Chat.
- **Selezione conversazione**: tap/click in sidebar ⇒ naviga alla Chat corrispondente.
- **Rinomina automatica**: alla prima risposta, suggerire titolo (prima frase) con fallback manuale via context menu.

### Theming e stile

- **Colori**: palette neutra (grigi/bianco) + accenti soft. Variabili centralizzate: `AppColors.sidebarBg`, `AppColors.chatBg`, `AppColors.userBubble`, `AppColors.assistantBubble`, `AppColors.codeBg`.
- **Tipografia**: `Font.title2`/`headline` per header; `body` per messaggi; `.monospaced()` per code.
- **Spaziatura**: scala 4/8/12/16/24; padding messaggi 12–16; gap verticale 8–12.
- **Dark Mode**: contrasto adeguato per code block e divider.

### File e responsabilità (da creare in `GPT/`)

- `Views/AppRootView.swift`: shell `NavigationSplitView` e routing.
- `Views/Sidebar/SidebarView.swift`, `ConversationRowView.swift`.
- `Views/Home/HomeView.swift`.
- `Views/Chat/ChatView.swift`, `MessageRowView.swift`, `ComposerView.swift`, `ModelPickerView.swift`.
- `Views/Shared/MarkdownMessageView.swift`, `CodeBlockView.swift`, `AvatarView.swift`.
- `Design/AppColors.swift`, `Design/AppTypography.swift`, `Design/AppConstants.swift`.
- `Models/Conversation.swift`, `Models/Message.swift` (solo proprietà UI: id, role, text, timestamps, modelId, flags UI).
- `ViewModels/UIState.swift` (selezione conversazione, mock store in-memory solo per UI).

### Dati mock e separazione UI

- Protocollo `ConversationsUIStore` con metodi minimi (list, create, update title, delete, pin). Implementazione mock in-memory per popolare sidebar e chat senza backend.

### Accessibilità e produttività

- Shortcut: ⌘N (nuova chat), ⌘F (search conversazioni), ⌘⏎ (invio), Esc (stop typing), ⌘B (toggle sidebar).
- Focus management: focus su composer dopo invio/creazione nuova chat.

### Corrispondenza con @Screenshots

- Allineare layout di homepage e sidebar a `Screenshots/homepage.png` e `Screenshots/sidebar.png` (griglie, spaziature, cromie). Useremo i valori di spaziatura/colore indicati sopra per il pixel-parity.

### To-dos

- [ ] Creare App shell con NavigationSplitView e routing Homepage/Chat
- [ ] Implementare Sidebar con header, search, sezioni Pinned/Recent e row conversazioni
- [ ] Costruire Homepage con hero e griglia di suggested prompts + composer globale
- [ ] Aggiungere header Chat con titolo modello, stato e azioni (Stop/Clear)
- [ ] Renderizzare lista messaggi con bubble left/right, avatar e separator
- [ ] Implementare MarkdownMessageView con code block e pulsante Copy
- [ ] Creare Composer multiline con placeholder, invio ⌘⏎ e pulsante Send
- [ ] Aggiungere ModelPickerView (menu modelli) e badge conversazione
- [ ] Definire AppColors, AppTypography e AppConstants (spaziature) con Dark Mode
- [ ] Preparare store UI mock (in-memory) per conversazioni e selezione